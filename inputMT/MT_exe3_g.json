{
  "definition_multitape": {
    "tapes": 3,
    "description": "F1: entrada, F2: conta a's, F3: conta a's-1. Verifica b=2n e c=n-1",
    "states": ["q0", "qa", "qb", "qb2", "qc", "qcheck", "qf", "qreject"],
    "initial_state": "q0",
    "accept_state": "qf",
    "reject_state": "qreject",
    "input_alphabet": ["a", "b", "c"],
    "tape_alphabet": ["a", "b", "c", "X", "$", "_"],
    "blank_symbol": "_",
    "algorithm": [
      "1. q0: Requer pelo menos um 'a'. Primeiro 'a' marca $ em F2 e F3",
      "2. qa: Para cada 'a', escreve X em F2 (para b=2n) e X em F3 (para c=n-1)",
      "3. qb/qb2: Para cada 'b', apaga 2 X's de F2",
      "4. qc: Para cada 'c', apaga 1 X de F3",
      "5. qcheck: Verifica se F2=$, F3 tem exatamente 1 X (n-1 c's + 1 = n)"
    ],
    "transitions": [
      "(q0, [_, _, _]) -> (qreject, [_, _, _], [N, N, N])",
      "(q0, [a, _, _]) -> (qa, [a, $, $], [R, R, R])",
      "(q0, [b, _, _]) -> (qreject, [b, _, _], [N, N, N])",
      "(q0, [c, _, _]) -> (qreject, [c, _, _], [N, N, N])",
      
      "(qa, [a, _, _]) -> (qa, [a, X, X], [R, R, R])",
      "(qa, [a, X, _]) -> (qa, [a, X, X], [R, R, R])",
      "(qa, [a, X, X]) -> (qa, [a, X, X], [R, R, R])",
      "(qa, [b, X, X]) -> (qb, [b, X, X], [N, N, L])",
      "(qa, [b, X, _]) -> (qb, [b, X, _], [N, N, N])",
      "(qa, [_, X, X]) -> (qreject, [_, X, X], [N, N, N])",
      "(qa, [_, X, _]) -> (qreject, [_, X, _], [N, N, N])",
      "(qa, [c, X, X]) -> (qreject, [c, X, X], [N, N, N])",
      
      "(qb, [b, X, X]) -> (qb2, [b, _, X], [N, L, N])",
      "(qb, [b, X, $]) -> (qb2, [b, _, $], [N, L, N])",
      "(qb, [b, $, X]) -> (qreject, [b, $, X], [N, N, N])",
      "(qb, [b, $, $]) -> (qreject, [b, $, $], [N, N, N])",
      
      "(qb2, [b, X, X]) -> (qb, [b, _, X], [R, N, N])",
      "(qb2, [b, X, $]) -> (qb, [b, _, $], [R, N, N])",
      "(qb2, [b, $, X]) -> (qreject, [b, $, X], [N, N, N])",
      "(qb2, [b, $, $]) -> (qreject, [b, $, $], [N, N, N])",
      
      "(qb, [c, $, X]) -> (qc, [c, $, _], [R, N, L])",
      "(qb, [c, $, $]) -> (qcheck, [c, $, $], [N, N, N])",
      "(qb, [c, X, X]) -> (qreject, [c, X, X], [N, N, N])",
      "(qb, [_, $, X]) -> (qcheck, [_, $, X], [N, N, N])",
      "(qb, [_, $, $]) -> (qreject, [_, $, $], [N, N, N])",
      
      "(qc, [c, $, X]) -> (qc, [c, $, _], [R, N, L])",
      "(qc, [c, $, $]) -> (qreject, [c, $, $], [N, N, N])",
      "(qc, [_, $, X]) -> (qcheck, [_, $, X], [N, N, N])",
      "(qc, [_, $, $]) -> (qreject, [_, $, $], [N, N, N])",
      
      "(qcheck, [_, $, X]) -> (qf, [_, $, X], [N, N, N])",
      "(qcheck, [c, $, $]) -> (qreject, [c, $, $], [N, N, N])"
    ]
  },
  "rules": [
    {
      "rules": [
        {
          "type": "structuredLanguage",
          "symbols": ["a", "b", "c"],
          "condition": "j === 2 * i && k === i - 1 && i >= 1",
          "negated": false
        }
      ]
    }
  ],
  "description": "MT Multifita (3 fitas): L = {a^n b^(2n) c^(n-1) | n > 0}",
  "complexity": {
    "standard": "O(nÂ²)",
    "multitape": "O(n)",
    "reason": "Multifita conta a's, b's e c's em paralelo em O(n)"
  }
}
