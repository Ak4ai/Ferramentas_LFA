{
  "definition_multitape": {
    "tapes": 3,
    "description": "F1: entrada, F2: conta i/j, F3: conta j/k. i=j OU j=k",
    "states": ["q0", "qi", "qb", "qk", "qchk_ij", "qchk_jk", "qf", "qreject"],
    "initial_state": "q0",
    "accept_state": "qf",
    "reject_state": "qreject",
    "input_alphabet": ["a", "b"],
    "tape_alphabet": ["a", "b", "X", "Y", "$", "_"],
    "blank_symbol": "_",
    "algorithm": [
      "1. q0: String vazia aceita (i=j=k=0). Primeiro 'a' marca $",
      "2. qi: Conta a's iniciais com X em F2 (para i=j) e X em F3 (para comparar)",
      "3. qb: Para cada 'b', escreve Y em F2 (para i=j) e Y em F3 (para j=k)",
      "4. qk: Para cada 'a' final, apaga Y de F3 (para j=k)",
      "5. qchk: Aceita se F2 tem #X=#Y (i=j) OU F3 tem #Y=0 após k (j=k)"
    ],
    "transitions": [
      "(q0, [_, _, _]) -> (qf, [_, _, _], [N, N, N])",
      "(q0, [a, _, _]) -> (qi, [a, $, $], [N, R, R])",
      "(q0, [b, _, _]) -> (qb, [b, $, $], [N, N, N])",
      
      "(qi, [a, $, $]) -> (qi, [a, X, X], [R, R, R])",
      "(qi, [a, X, X]) -> (qi, [a, X, X], [R, R, R])",
      "(qi, [a, _, X]) -> (qi, [a, X, X], [R, R, R])",
      "(qi, [a, X, _]) -> (qi, [a, X, X], [R, R, R])",
      "(qi, [b, X, X]) -> (qb, [b, Y, Y], [R, R, R])",
      "(qi, [b, $, X]) -> (qb, [b, Y, Y], [R, R, R])",
      "(qi, [b, X, $]) -> (qb, [b, Y, Y], [R, R, R])",
      "(qi, [b, $, $]) -> (qb, [b, Y, Y], [R, R, R])",
      "(qi, [_, X, X]) -> (qchk_ij, [_, X, X], [N, L, L])",
      "(qi, [_, $, $]) -> (qf, [_, $, $], [N, N, N])",
      "(qi, [_, X, $]) -> (qchk_ij, [_, X, $], [N, L, N])",
      "(qi, [_, $, X]) -> (qreject, [_, $, X], [N, N, N])",
      
      "(qb, [b, _, _]) -> (qb, [b, Y, Y], [R, R, R])",
      "(qb, [b, Y, _]) -> (qb, [b, Y, Y], [R, R, R])",
      "(qb, [b, _, Y]) -> (qb, [b, Y, Y], [R, R, R])",
      "(qb, [b, Y, Y]) -> (qb, [b, Y, Y], [R, R, R])",
      "(qb, [a, Y, Y]) -> (qk, [a, Y, _], [R, N, L])",
      "(qb, [a, _, Y]) -> (qk, [a, _, _], [R, N, L])",
      "(qb, [a, Y, _]) -> (qk, [a, Y, _], [R, N, N])",
      "(qb, [_, Y, Y]) -> (qchk_ij, [_, Y, Y], [N, L, L])",
      "(qb, [_, _, Y]) -> (qchk_jk, [_, _, Y], [N, N, L])",
      "(qb, [_, Y, _]) -> (qchk_ij, [_, Y, _], [N, L, N])",
      "(qb, [_, _, _]) -> (qf, [_, _, _], [N, N, N])",
      
      "(qk, [a, Y, Y]) -> (qk, [a, Y, _], [R, N, L])",
      "(qk, [a, Y, _]) -> (qk, [a, Y, _], [R, N, N])",
      "(qk, [a, _, Y]) -> (qk, [a, _, _], [R, N, L])",
      "(qk, [a, _, _]) -> (qk, [a, _, _], [R, N, N])",
      "(qk, [b, Y, Y]) -> (qreject, [b, Y, Y], [N, N, N])",
      "(qk, [_, Y, Y]) -> (qchk_ij, [_, Y, Y], [N, L, L])",
      "(qk, [_, _, Y]) -> (qchk_jk, [_, _, Y], [N, N, L])",
      "(qk, [_, Y, _]) -> (qchk_ij, [_, Y, _], [N, L, N])",
      "(qk, [_, Y, $]) -> (qchk_jk, [_, Y, $], [N, N, N])",
      "(qk, [_, _, $]) -> (qf, [_, _, $], [N, N, N])",
      "(qk, [_, _, _]) -> (qf, [_, _, _], [N, N, N])",
      
      "(qchk_ij, [_, X, X]) -> (qchk_ij, [_, X, X], [N, L, L])",
      "(qchk_ij, [_, Y, Y]) -> (qchk_ij, [_, Y, Y], [N, L, L])",
      "(qchk_ij, [_, X, Y]) -> (qchk_ij, [_, X, Y], [N, L, L])",
      "(qchk_ij, [_, Y, X]) -> (qchk_ij, [_, Y, X], [N, L, L])",
      "(qchk_ij, [_, X, $]) -> (qchk_ij, [_, X, $], [N, L, N])",
      "(qchk_ij, [_, Y, $]) -> (qchk_ij, [_, Y, $], [N, L, N])",
      "(qchk_ij, [_, $, X]) -> (qreject, [_, $, X], [N, N, N])",
      "(qchk_ij, [_, $, Y]) -> (qchk_jk, [_, $, Y], [N, N, L])",
      "(qchk_ij, [_, $, $]) -> (qf, [_, $, $], [N, N, N])",
      
      "(qchk_jk, [_, _, Y]) -> (qchk_jk, [_, _, Y], [N, N, L])",
      "(qchk_jk, [_, Y, Y]) -> (qchk_jk, [_, Y, Y], [N, N, L])",
      "(qchk_jk, [_, _, $]) -> (qf, [_, _, $], [N, N, N])",
      "(qchk_jk, [_, Y, $]) -> (qf, [_, Y, $], [N, N, N])",
      "(qchk_jk, [_, $, $]) -> (qf, [_, $, $], [N, N, N])"
    ]
  },
  "rules": [
    {
      "rules": [
        {
          "type": "structuredLanguage",
          "symbols": ["a", "b", "a"],
          "condition": "i === j || j === k",
          "negated": false
        }
      ]
    }
  ],
  "description": "MT Multifita (3 fitas): L = {a^i b^j a^k | i = j OU j = k}",
  "complexity": {
    "standard": "O(n²)",
    "multitape": "O(n)",
    "reason": "Multifita conta i, j, k em paralelo e verifica condições em O(n)"
  }
}
